## 什么是闭包
闭包（closure）是javascript的一大难点，也是它的特色。

#### 简而言之：闭包就是能够访问函数内部变量的函数。

## 作用域

> 要理解闭包，首先要理解javascript的特殊的变量作用域。javascript语言的特别之处就在于：函数内部可以直接读取全局变量，但是在函数外部无法读取函数内部的局部变量。在函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明的是一个全局变量！

#### 如何从外部读取函数内部的局部变量？
> 出于种种原因，我们有时候需要获取到函数内部的局部变量。但是，上面已经说过了，正常情况下，这是办不到的！只有通过变通的方法才能实现。

那就是在函数内部，再定义一个函数。

```javascript
function f1(){
　　var n=999;
　　return function f2(){
      return n+=1;
　　}
}
var temp = f1();
console.log(temp()) //1000   
console.log(temp()) //1001   修改内部变量n的值
console.log(temp()) //1002   获得上一次修改的值并开始累加 
```
在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。

这就是Javascript语言特有的"链式作用域"结构（chain scope），

子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。

既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！

#### 上面代码中的f2函数，就是闭包,所以，在本质上，闭包是将函数内部和函数外部连接起来的桥梁。

## 闭包的用途

* 可以读取函数内部的变量

* 另一个就是让这些变量的值始终保持在内存中，不会在f1调用后被自动清除。

* 例子每一次调用f2的过程相当于修改了内部变量n的值，这也是闭包最大的特点 。

> 为什么会这样呢？原因就在于f1是f2的父函数，而<font color=red>f2被赋给了一个全局变量</font>，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。

## 使用闭包的注意点

* 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。

* 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。
